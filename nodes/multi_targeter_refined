#!/usr/bin/env python
import numpy as np
import threading
import time

import roslib; roslib.load_manifest('flymad')
import rospy

from flymad.msg import TrackedObj
from geometry_msgs.msg import Vector3
from std_msgs.msg import UInt8, Int64
from flymad.msg import MicroVelocity, MicroPosition, TargetedObj

from flymad.laser_camera_calibration import load_calibration
from flymad.util import myint16
from flymad.hitutils import HitBox, HitImage

PRINT_TIME      = False
PRINT_DAC       = True
PRINT_STATE     = False
PRINT_UPDATE    = False

PX = -0.5
PY = -0.5

LASER_POWER_ON  = 255 #0 -> 255
LASER_POWER_OFF = 0

MOTOR_LAG       = 0.015

HIT_DURATION    = 0.2   # seconds
MANAGEMENT_RATE = max(10,2.0/HIT_DURATION)

THRESHOLD_DISTANCE_PIXELS       = 10.0 # when to switch to TTL

(MODE_IDLE,
 MODE_WIDE,
 MODE_ZOOM) = range(3)

class _Timer(object):
    def __init__(self, name=None):
        self.name = name

    def __enter__(self):
        self.tstart = time.time()

    def __exit__(self, type, value, traceback):
        if self.name:
            print '[%s]' % self.name,
        print 'elapsed: %.3fms' % (1000.0*(time.time() - self.tstart))

class _FakeTimer(object):
    def __init__(self, *args, **kwargs):
        pass

    def __enter__(self):
        pass

    def __exit__(self, type, value, traceback):
        pass

Timer = _Timer if PRINT_TIME else _FakeTimer

class MaybeTargetedObject:

    _t0 = time.time()
    should_target   = False
    obj_id = -1

    def __init__(self,msg,hitmanager):
        self.msg = msg
        self.obj_id = msg.obj_id
        self.hitmanager = hitmanager
        self.target_type = ' ' #w,f or ' ' (f = TTL and being lasered)
        self.laser_last_hit  = 0
        self.laser_total_hit = 0.0
        self.laser_first_hit = True

    def __str__(self):
        s = self.msg.state_vec
        return '%cobj %d at %.1f,%.1f, hit=%.1f (lst=%.2f) t:%c l:%c' % (
                    self.target_type,
                    self.msg.obj_id,
                    s[0],s[1],
                    self.laser_total_hit,self.laser_last_hit-self._t0,
                    'Y' if self.should_target else 'N',
                    'Y' if self.should_laser() else 'N',
        )

    def __repr__(self):
        return 'MaybeTargetedObject('+str(self)+')'

    def __cmp__(self, other):
        #sorted sorts in ascending order, so most recent time.time() values are
        #at the end, and oldest time.time() values at the start
        return cmp(self.laser_last_hit,other.laser_last_hit)

    def update_laser(self, now):
        assert isinstance(now, float)

        if not self.laser_first_hit:
            self.laser_total_hit += (now - self.laser_last_hit)

        self.laser_last_hit = now
        self.laser_first_hit = False

    def reset_laser(self):
        self.laser_first_hit = True
        self.laser_total_hit = 0

    def update_position(self,msg):
        assert self.obj_id == msg.obj_id

        #was_target = self.should_target
        self.should_target  = self.hitmanager.should_target(int(msg.state_vec[0]), int(msg.state_vec[1]))
        self.msg = msg

    def update_targeting(self, target_obj_id, which):
        assert which in 'wf'

        is_targeted = self.obj_id == target_obj_id
        self.target_type = which if is_targeted else ' '

        return is_targeted

    def should_laser(self):
        if self.should_target:
            return self.laser_total_hit < HIT_DURATION
        return False


class Targeter:
    def __init__(self, cal_fname, target_when_inside, borders_x, borders_y):
        self.cal = load_calibration(cal_fname)

        if None in (borders_x, borders_y):
            self.hitmanager = HitImage(target_when_inside)
        else:
            self.hitmanager = HitBox(target_when_inside, borders_x, borders_y)

        self.dacs       = 0,0
        self.last_vals  = 0,0,LASER_POWER_OFF #a,b,laser

        self.zoom_misses = 0

        #use this lock to protect the tracked objects
        self.plan_lock      = threading.Lock()
        self.current_plan   = ('idle',0,LASER_POWER_OFF) #(plan name, obj_id, laser_power)
        self.tracked_objects = {} # a dict of currently tracked objects

        self.pub_dac_position = rospy.Publisher('/flymad_micro/position',
                                                MicroPosition,
                                                tcp_nodelay=True)
        self.pub_dac_velocity = rospy.Publisher('/flymad_micro/velocity',
                                                MicroVelocity,
                                                tcp_nodelay=True)

        self.pub_targeted = rospy.Publisher('/targeter/targeted',
                                            TargetedObj,
                                            tcp_nodelay=True)

        self.point_mirrors_at_nothing()

        _ = rospy.Subscriber('/flymad/tracked',
                             TrackedObj,
                             self.on_tracking)
        _ = rospy.Subscriber('/flymad_micro/position_echo',
                             MicroPosition,
                             self.on_dac)
        _ = rospy.Subscriber('/flymad/laser_head_delta',
                             Vector3,
                             self.on_head_delta)
        _ = rospy.Subscriber('/flymad/target_object',
                             Int64,
                             self.on_target_object)

    def on_target_object(self, msg):
        with self.plan_lock:
            self.set_current_plan('point mirror',msg.data,LASER_POWER_OFF,reason='manual')

    def on_dac(self,msg):
        self.dacs = msg.posA, msg.posB

    def on_head_delta(self,msg):
        """
        the realtime tracking is done here, whenever we get a tracking message. The
        experimental logic (i.e. tracking fly membership in the hit dict, etc)
        is done in update.

        realtime tracking is done using the through the lens camera only
        """
        with Timer('head'):
            with self.plan_lock:
                plan,plan_obj_id,laser_power = self.current_plan

                if plan != "zap start":
                    return

                now = rospy.Time.now().to_sec()
                for obj in self.tracked_objects.values():
                    if obj.update_targeting(plan_obj_id,'f'):
                        assert plan_obj_id == obj.obj_id

                        dx = msg.x
                        dy = msg.y

                        miss = np.abs(dx) > 300
                        if miss:
                            self.zoom_misses += 1

                        if self.zoom_misses > 10:
                            #we have lost the fly, or have a bad estimate, go back to pre zap (wide camera)
                            self.set_current_plan('point mirror', obj.obj_id,laser_power,
                                        reason='%d misses'%self.zoom_misses)

                        if not miss:
                            a,b,_ = self.last_vals
                            cmdA = a+(PX*dx)
                            cmdB = b+(PY*dy)

#                            if obj.should_laser():
#                                obj.update_laser(now)

                            self.send_dac(cmdA, cmdB, laser_power, obj.obj_id)
                            obj.update_laser(now)

                            #SEND TARGET MESSAGE
                            x,y,lx,ly = self.get_obj_xy_and_laser_xy(obj)
                            self.send_targeted(obj.obj_id, x, y, lx, ly, laser_power, MODE_ZOOM)



    def on_tracking(self, msg):
        with Timer('trck'):
            #update the position of all objects
            with self.plan_lock:
                plan,plan_obj_id,laser_power = self.current_plan
                obj_id = msg.obj_id

                if obj_id not in self.tracked_objects:
                    self.tracked_objects[obj_id] = MaybeTargetedObject(msg, self.hitmanager)

                self.tracked_objects[obj_id].update_position(msg)

                if not msg.is_living:
                    del self.tracked_objects[obj_id]

                if plan != 'point mirror':
                    return

                now = rospy.Time.now().to_sec()
                for obj in self.tracked_objects.values():
                    if obj.update_targeting(plan_obj_id,'w'):
                        assert plan_obj_id == obj.obj_id

                        #get the current fly position and galvo/laser position
                        x,y,lx,ly = self.get_obj_xy_and_laser_xy(obj)
                        #immediately point at the fly (because the next frame might be
                        #a head delta, in which case we will switch to TTL tracking
                        self.point_mirrors_at_xy(x,y,obj.obj_id,laser_power)
                        obj.update_laser(now)

                        #SEND TARGET MESSAGE
                        self.send_targeted(obj.obj_id, x, y, lx, ly, laser_power, MODE_WIDE)

                        #but if the fly is already in the centre of the view then use the zoom
                        #camera for the next tracking
                        laser_distance = np.sqrt((lx-x)**2 + (ly-y)**2)
                        if laser_distance < THRESHOLD_DISTANCE_PIXELS:
                            self.set_current_plan('zap start', obj.obj_id,laser_power,
                                        reason='close %.1f' % laser_distance)

    def update(self):
        with Timer('upd8'):
            with self.plan_lock:
                plan,plan_obj_id,laser_power = self.current_plan

                to_hit = []
                to_reset = []
                is_targeted = None

                if PRINT_UPDATE:
                    print "-------------"

                for obj in self.tracked_objects.values():
                    if PRINT_UPDATE:
                        print "? ",plan_obj_id,"=",obj

                    #are we already targeting this fly
                    if obj.should_laser():
                        if obj.obj_id == plan_obj_id:
                            is_targeted = obj
                        else:
                            to_hit.append( obj )
                    else:
                        to_reset.append( obj )

                if to_hit and (is_targeted is None):
                    #t[0] now contains the object hit least recently (see __cmp__)
                    to_hit.sort()
                    obj = to_hit[0]
                    self.set_current_plan('point mirror', obj.obj_id,LASER_POWER_ON,reason='your turn')
                elif (not to_hit) and (is_targeted is None):
                    off_lp = LASER_POWER_ON
                    #turn off the laser, no flies to track, nothing to do
                    self.set_current_plan('idle',0,off_lp,reason='laser off')
                    self.send_dac(0, -12000, off_lp, 0)

                for obj in to_reset:
                    obj.reset_laser()


    def set_current_plan(self,plan,obj_id,laser_power,reason=''):
        assert isinstance(obj_id, int)

        if plan == 'zap start':
            self.zoom_misses = 0
        self.current_plan = (plan,obj_id,laser_power)

        if PRINT_STATE:
            print "-> {0:<13s}({1:<10s}) : {2:s}".format(plan,reason,self.tracked_objects.get(obj_id))

    def get_obj_xy(self,obj,predict=False):
        """return the object position, optionally predicting
        the fly position from its velocity inorder to cancel out motor lag"""
        assert isinstance(obj, MaybeTargetedObject)

        msg = obj.msg
        s = msg.state_vec

        if predict:
            now = rospy.Time.now()

            dt = now-msg.header.stamp # time elapsed since we have updated information
            dt_sec = dt.to_sec()

            xp = s[2]*(dt_sec+MOTOR_LAG)
            yp = s[3]*(dt_sec+MOTOR_LAG)
        else:
            xp = 0
            yp = 0

        x = int(max(0,s[0] + xp))
        y = int(max(0,s[1] + yp))

        return x,y

    def get_obj_xy_and_laser_xy(self,obj):
        assert isinstance(obj, MaybeTargetedObject)

        x,y = self.get_obj_xy(obj)
        aa, ab = self.dacs
        dac_pixel_x = self.cal.d2px((aa,ab))
        dac_pixel_y = self.cal.d2py((aa,ab))

        return x,y,dac_pixel_x,dac_pixel_y

    def point_mirrors_at_nothing(self,laser_power=LASER_POWER_OFF):
        self.point_mirrors_at_xy(250,250,0,laser_power)

    def point_mirrors_at_xy(self,x,y,obj_id,laser_power):
        # desired
        bad_data = False
        try:
            daca = self.cal.p2da[y,x]
            dacb = self.cal.p2db[y,x]
        except IndexError:
            bad_data = True
        else:
            if np.isnan( daca ) or np.isnan( dacb ):
                bad_data = True
        
        if bad_data:
            # Hmm, should we do something more?
            return

        self.send_dac(daca, dacb, laser_power, obj_id)

    def turnoff_laser(self):
        a,b,_ = self.last_vals
        msg = MicroPosition(a, b, LASER_POWER_OFF)
        this_vals = msg.posA, msg.posB, msg.laser
        self.pub_dac_position.publish(msg)
        self.last_vals = this_vals

    def send_dac(self, daca, dacb, laser_power, obj_id):

        # position mode
        msg = MicroPosition(myint16(daca), myint16(dacb), laser_power)
        this_vals = msg.posA, msg.posB, msg.laser
        if this_vals != self.last_vals:
            self.pub_dac_position.publish(msg)
            self.last_vals = this_vals

        if PRINT_DAC:
            print repr(self.tracked_objects.get(obj_id))

    def send_targeted(self, obj_id, fly_x, fly_y, laser_x, laser_y, laser_power, mode):
        msg = TargetedObj()
        msg.header.stamp = rospy.Time.now()
        msg.obj_id = int(obj_id)
        msg.fly_x = float(fly_x)
        msg.fly_y = float(fly_y)
        msg.laser_x = float(laser_x)
        msg.laser_y = float(laser_y)
        msg.laser_power = int(laser_power)
        msg.mode = int(mode)
        self.pub_targeted.publish(msg)

    def run(self):
        r = rospy.Rate(MANAGEMENT_RATE)

        while not rospy.is_shutdown():
            self.update()
            r.sleep()

        #turn off the laser, etc
        self.pub_dac_position.publish(MicroPosition())

if __name__=='__main__':
    rospy.init_node('flymad_targeter')

    import argparse
    parser = argparse.ArgumentParser(
                'multi_targeter_refined',
                epilog='flies are targeted when inside the specified area, unless '\
                       '--outside is given.\n'\
                       'if --borders_{x,y} is not given, listen to ROS topics /draw_geom/... '\
                       'for an arbitary polygon defining the targeting area.\n\n'
    )

    parser.add_argument('calibration', nargs=1, help='calibration yaml')
    parser.add_argument('--borders_x', nargs=2, metavar=('X0','X1'),
                            default=None, help='borders for targeting')
    parser.add_argument('--borders_y', nargs=2, metavar=('Y0','Y1'),
                            default=None, help='borders for targeting')
    parser.add_argument('--outside', action='store_false', default=True,
                            dest='target_when_inside',
                            help='targeted when outside')

    args = parser.parse_args(rospy.myargv()[1:])

    t = Targeter(args.calibration[0], args.target_when_inside, args.borders_x, args.borders_y)
    t.run()

