#!/usr/bin/env python
import numpy as np
import adskalman.adskalman as adskalman
import sys
import threading
import time
import Queue
import Image

import roslib; roslib.load_manifest('flymad')
import rospy

from flymad.msg import Raw2dPositions, TrackedObj
from geometry_msgs.msg import Pose2D, Vector3
from std_msgs.msg import UInt8, Int64, String
from flymad.msg import MicroVelocity, MicroPosition, StampedObject, Plan


from flymad.laser_camera_calibration import load_calibration
from flymad.util import myint32, myint16
from flymad.constants import FPS
from flymad.hitutils import HitBox, HitImage

MOTOR_LAG       = 0.015

HIT_START_FREQ  = 10.0 # 10 Hz
HIT_DURATION    = 5 # 10 msec
HIT_START_DT    = rospy.Duration(1.0/ HIT_START_FREQ)

THRESHOLD_DISTANCE_PIXELS       = 10.0 # when to switch to TTL

def str_to_code(plan):
    if plan=='idle':
        code = 0
    elif plan=="point mirror":
        code = 1
    elif plan=="zap start":
        code = 2
    elif plan=="zap continue":
        code = 3
    else:
        raise ValueError('unknown plan: %r'%plan)
    return code

TTL_MODES = set(("zap start","zap continue"))

class _Timer(object):
    def __init__(self, name=None):
        self.name = name

    def __enter__(self):
        self.tstart = time.time()

    def __exit__(self, type, value, traceback):
        if self.name:
            print '[%s]' % self.name,
        print 'elapsed: %.3fms' % (1000.0*(time.time() - self.tstart))

class _FakeTimer(object):
    def __init__(self, *args, **kwargs):
        pass

    def __enter__(self):
        pass

    def __exit__(self, type, value, traceback):
        pass

Timer = _FakeTimer

class MaybeTargetedObject:

    is_in_area = False

    def __init__(self,msg,hitmanager):
        self.msg = msg
        self.last_hit_time  = 0
        self.total_hit_time = 0.0
        self.hitmanager = hitmanager

    def __str__(self):
        s = self.msg.state_vec
        return 'obj %d at %.1f,%.1f, hit for %.1f (last %.2f) in %c' % (
                    self.msg.obj_id,
                    s[0],s[1],
                    self.total_hit_time,self.last_hit_time,
                    'Y' if self.is_in_area else 'N'
        )

    def __repr__(self):
        return 'MaybeTargetedObject('+str(self)+')'

    def __cmp__(self, other):
        #sorted sorts in ascending order, so most recent time.time() values are
        #at the end, and oldest time.time() values at the start
        return cmp(self.last_hit_time,other.last_hit_time)

    def update_position(self,msg):
        self.is_in_area  = self.hitmanager.in_area(int(msg.state_vec[0]), int(msg.state_vec[1]))
        self.msg = msg

    def hit_with_laser(self, now):
        assert isinstance(now, float)
        if self.last_hit_time != 0:
            self.total_hit_time += (now - self.last_hit_time)
        self.last_hit_time  = now

    def is_targeted(self, obj_id):
        return (self.msg.obj_id == obj_id)

class Targeter:
    def __init__(self, cal_fname, borders_x, borders_y):
        self.cal = load_calibration(cal_fname)

        if None in (borders_x, borders_y):
            self.hitmanager = HitImage()
        else:
            self.hitmanager = HitBox(borders_x, borders_y)

        self.dacs = 0,0

        self.zoom_misses = 0

        #use this lock to protect the tracked objects
        self.plan_lock      = threading.Lock()
        self.current_plan   = ('idle',-1) #(plan name, obj_id)
        self.tracked_objects = {} # a dict of currently tracked objects

        self.dac_lock       = threading.Lock()
        self.last_vals      = None

        self.pub_plan = rospy.Publisher('/multi_targeter/plan',
                                        Plan)
        self.pub_dac_position = rospy.Publisher('/flymad_micro/position',
                                                MicroPosition,
                                                tcp_nodelay=True)
        self.pub_dac_velocity = rospy.Publisher('/flymad_micro/velocity',
                                                MicroVelocity,
                                                tcp_nodelay=True)
        self.pub_laser = rospy.Publisher('/flymad_micro/laser',
                                         UInt8,
                                         tcp_nodelay=True)

        self.pub_targeted = rospy.Publisher('/flymad/targeted',
                                            StampedObject,
                                            tcp_nodelay=True)

        self.last_vals = None
        self.point_mirrors_at_nothing()

        _ = rospy.Subscriber('/flymad/tracked',
                             TrackedObj,
                             self.on_tracking)
        _ = rospy.Subscriber('/flymad_micro/position_echo',
                             MicroPosition,
                             self.on_dac)
        _ = rospy.Subscriber('/flymad/laser_head_delta',
                             Vector3,
                             self.on_head_delta)
        _ = rospy.Subscriber('/flymad/target_object',
                             Int64,
                             self.on_target_object)

    def on_target_object(self, msg):
        with self.plan_lock:
            self.set_current_plan('point mirror',msg.data,reason='manual')

    def on_dac(self,msg):
        self.dacs = msg.posA, msg.posB

    def on_head_delta(self,msg):
        """
        the realtime tracking is done here, whenever we get a tracking message. The
        experimental logic (i.e. tracking fly membership in the hit dict, etc)
        is done in update.

        realtime tracking is done using the through the lens camera only
        """
        with Timer('head'):
            with self.plan_lock:
                plan,plan_obj_id = self.current_plan
                obj = self.tracked_objects.get(plan_obj_id)

                if plan not in TTL_MODES:
                    return

                if not (obj and obj.is_targeted(plan_obj_id)):
                    return

                dx = msg.x
                dy = msg.y

                miss = np.abs(dx) > 300
                if miss:
                    self.zoom_misses += 1

                if self.zoom_misses > 10:
                    #we have lost the fly, or have a bad estimate, go back to pre zap (wide camera)
                    self.set_current_plan('point mirror', plan_obj_id, reason='%d misses'%self.zoom_misses)

                if not miss:
                    PX = -0.4
                    PY = -0.4
                    a,b = self.last_vals
                    cmdA = a+(PX*dx)
                    cmdB = b+(PY*dy)
                    self.send_dac(cmdA, cmdB, plan_obj_id,'zoom')

    def on_tracking(self, msg):
        with Timer('trck'):
            #update the position of all objects
            with self.plan_lock:
                plan,plan_obj_id = self.current_plan
                obj_id = msg.obj_id

                if obj_id not in self.tracked_objects:
                    self.tracked_objects[obj_id] = MaybeTargetedObject(msg, self.hitmanager)

                self.tracked_objects[obj_id].update_position(msg)

                if not msg.is_living:
                    del self.tracked_objects[obj_id]

                obj = self.tracked_objects.get(obj_id)

                if plan != 'point mirror':
                    return

                if not obj:
                    return

                if obj.is_targeted(plan_obj_id):
                    #point at the updated position
                    self.point_mirrors_at_msg(msg)
                    #but if the fly is already in the centre of the view then use the zoom camera for
                    #the next tracking
                    laser_distance = self.get_laser_distance(obj)
                    if laser_distance < THRESHOLD_DISTANCE_PIXELS:
                        self.set_current_plan('zap start', obj_id, reason='close (%.1f)' % laser_distance)

    def update(self):
        with Timer('upd8'):
            with self.plan_lock:
                print [obj for obj in self.tracked_objects.values() if obj.is_in_area]

    def set_current_plan(self,plan,obj_id,reason=''):
        assert isinstance(obj_id, int)

        obj = self.tracked_objects.get(obj_id)
        #we just lost the object in between this call executing
        if not obj:
            return

        if plan == 'zap start':
            self.zoom_misses = 0

        self.current_plan = (plan,obj_id)

        print "{0:<15s}({1:<10s}) : {2:s}".format(plan,reason,repr(obj))

        #msg = Plan()
        #msg.plan_code = int(str_to_code(plan))
        #if obj is not None:
        #    msg.obj_id = obj.msg.obj_id
        #    if np.isnan(self.get_laser_distance(obj)) is False:
        #        msg.distance = int(self.get_laser_distance(obj))
        #else:
        #    msg.obj_id = 0

        #msg.stamp = now
        #msg.number = int(len(self.tracked_objects))
        #msg.numberhit = int(len(self.hit_dict))

        #self.pub_plan.publish(msg)

    def get_msg_xy(self,msg,predict=False):
        """return the object position, optionally predicting
        the fly position from its velocity inorder to cancel out motor lag"""
        s = msg.state_vec

        if predict:
            now = rospy.Time.now()

            dt = now-msg.header.stamp # time elapsed since we have updated information
            dt_sec = dt.to_sec()

            xp = s[2]*(dt_sec+MOTOR_LAG)
            yp = s[3]*(dt_sec+MOTOR_LAG)
        else:
            xp = 0
            yp = 0

        x = int(max(0,s[0] + xp))
        y = int(max(0,s[1] + yp))

        return x,y

    def get_laser_distance(self,obj):
        x,y = self.get_msg_xy(obj.msg)

        aa, ab = self.dacs
        dac_pixel_x = self.cal.d2px((aa,ab))
        dac_pixel_y = self.cal.d2py((aa,ab))

        laser_distance = np.sqrt((dac_pixel_x-x)**2 + (dac_pixel_y-y)**2)

        return laser_distance

    def point_mirrors_at_msg(self,msg):
        x,y = self.get_msg_xy(msg)
        self.point_mirrors_at_xy(x,y,msg.obj_id)

    def point_mirrors_at_nothing(self):
        self.point_mirrors_at_xy(250,250,0)

    def point_mirrors_at_xy(self,x,y,obj_id):
        # desired
        bad_data = False
        try:
            daca = self.cal.p2da[y,x]
            dacb = self.cal.p2db[y,x]
        except IndexError:
            bad_data = True
        else:
            if np.isnan( daca ) or np.isnan( dacb ):
                bad_data = True
        
        if bad_data:
            # Hmm, should we do something more?
            return

        self.send_dac(daca,dacb,obj_id,'wide')

    def send_dac(self,daca,dacb,obj_id,which):

        # position mode
        msg = MicroPosition(myint16(daca), myint16(dacb))
        this_vals = msg.posA, msg.posB
        if this_vals != self.last_vals:
            self.pub_dac_position.publish(msg)
            self.last_vals = this_vals

        #ix = msg.posA, msg.posB
        #px = self.cal.d2px(ix)
        #py = self.cal.d2py(ix)

        msg = StampedObject()
        msg.header.stamp = rospy.Time.now()
        msg.obj_id = obj_id
        self.pub_targeted.publish(msg)

    def run(self):
        r = rospy.Rate(100)
        startall = time.time()
        while not rospy.is_shutdown() and time.time() - startall < 600:
            self.update()
            r.sleep()
        self.pub_laser.publish( 0 )
        exit()    


if __name__=='__main__':
    rospy.init_node('flymad_targeter')

    import argparse
    parser = argparse.ArgumentParser()
    parser.add_argument('calibration', nargs=1, help='calibration yaml')
    parser.add_argument('--borders_x', nargs=2, metavar=('X0','X1'),
                            default=None, help='borders for targeting')
    parser.add_argument('--borders_y', nargs=2, metavar=('Y0','Y1'),
                            default=None, help='borders for targeting')

    args = parser.parse_args(rospy.myargv()[1:])

    t = Targeter(args.calibration[0], args.borders_x, args.borders_y)
    t.run()

