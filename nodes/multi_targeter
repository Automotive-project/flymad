#!/usr/bin/env python
import numpy as np
import adskalman.adskalman as adskalman
import sys
import threading
import time

import roslib; roslib.load_manifest('flymad')
import rospy

from flymad.msg import Raw2dPositions, TrackedObj
from geometry_msgs.msg import Pose2D
from std_msgs.msg import UInt8, Int64
from flymad.msg import MicroVelocity, MicroPosition, StampedObject

from flymad.laser_camera_calibration import load_calibration
from flymad.util import myint32
from flymad.constants import FPS

LATENCY = 0.05
K_PROPORTIONAL = 1e3

class Targeter:
    def __init__(self,cal_fname):
        self.cal = load_calibration(cal_fname)
        rospy.init_node('flymad_targeter')
        _ = rospy.Subscriber('/flymad/tracked',
                             TrackedObj,
                             self.on_tracking)
        _ = rospy.Subscriber('/flymad/target_object',
                             Int64,
                             self.on_target_object)
        _ = rospy.Subscriber('/flymad_micro/position_echo',
                             MicroPosition,
                             self.on_dac)
        self.pub_dac_position = rospy.Publisher('/flymad_micro/position',
                                                MicroPosition,
                                                tcp_nodelay=True)
        self.pub_dac_velocity = rospy.Publisher('/flymad_micro/velocity',
                                                MicroVelocity,
                                                tcp_nodelay=True)

        self.pub_targeted = rospy.Publisher('/flymad/targeted',
                                            StampedObject,
                                            tcp_nodelay=True)

        self.cur_obj_id = None
        self.lock = threading.Lock()
        self.dacs = 0,0
        self.last_vals = None
        time.sleep(0.4) # give ROS a chance to start up?!
        self.stop_tracking(None)

    def on_dac(self,msg):
        self.dacs = msg.posA, msg.posB

    def _get_current_dacs(self):
        return self.dacs

    def stop_tracking(self,old_obj_id):
        rospy.loginfo('stopped targeting object %s'%old_obj_id)
        self.cur_obj_id = None
        msg = MicroVelocity()
        msg.velA = myint32(0)
        msg.velB = myint32(0)
        this_vels = msg.velA, msg.velB
        if this_vels != self.last_vals:
            self.pub_dac_velocity.publish(msg)
            self.last_vals = this_vels

    def on_target_object(self, msg):
        obj_id = msg.data
        if obj_id < 0:
            self.stop_tracking(self.cur_obj_id)
        else:
            self.cur_obj_id = obj_id
            rospy.loginfo('now targeting object %d'%self.cur_obj_id)

    def on_tracking(self, msg):
        if self.cur_obj_id is None:
            self.cur_obj_id = msg.obj_id
            rospy.loginfo('now targeting object %d'%self.cur_obj_id)

        if self.cur_obj_id != msg.obj_id:
            return

        if not msg.is_living:
            self.stop_tracking(self.cur_obj_id)
            return

        # calculate fly position in pixel coordinates
        s = msg.state_vec
        x = s[0] + s[2]*LATENCY
        y = s[1] + s[3]*LATENCY

        x = int(max(0,x))
        y = int(max(0,y))

        # desired
        try:
            daca = self.cal.p2da[y,x]
            dacb = self.cal.p2db[y,x]
        except IndexError:
            return

        if 1:
            # velocity mode
            aa, ab = self._get_current_dacs()

            diffa = daca-aa
            diffb = dacb-ab

            dt = 1.0/FPS
            vela = diffa*dt*K_PROPORTIONAL
            velb = diffb*dt*K_PROPORTIONAL

            if np.isnan(vela) or np.isnan(velb):
                return
            msg = MicroVelocity()
            msg.velA = myint32(vela)
            msg.velB = myint32(velb)

            this_vels = msg.velA, msg.velB
            if this_vels != self.last_vals:
                self.pub_dac_velocity.publish(msg)
                self.last_vals = this_vels
        else:
            # position mode
            a = int(np.round(daca))
            b = int(np.round(dacb))
            msg = MicroPosition()
            msg.posA = a
            msg.posB = b
            assert msg.posA==a
            assert msg.posB==b
            this_vals = msg.posA, msg.posB
            if this_vals != self.last_vals:
                self.pub_dac_position.publish(msg)
                self.last_vals = this_vals

            ix = msg.posA, msg.posB
            px = self.cal.d2px(ix)
            py = self.cal.d2py(ix)

        msg = StampedObject()
        msg.header.stamp = rospy.Time.now()
        msg.obj_id = self.cur_obj_id
        self.pub_targeted.publish(msg)

    def run(self):
        rospy.spin()

if __name__=='__main__':
    cal_fname = sys.argv[1]
    t=Targeter(cal_fname)
    t.run()
