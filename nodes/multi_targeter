#!/usr/bin/env python
import numpy as np
import adskalman.adskalman as adskalman
import sys
import threading
import time
import Queue
import Image

import roslib; roslib.load_manifest('flymad')
import rospy

from flymad.msg import Raw2dPositions, TrackedObj
from geometry_msgs.msg import Pose2D
from std_msgs.msg import UInt8, Int64
from flymad.msg import MicroVelocity, MicroPosition, StampedObject

from flymad.laser_camera_calibration import load_calibration
from flymad.util import myint32
from flymad.constants import FPS

MOTOR_LAG = 0.01
K_PROPORTIONAL = 1e3/30.0

HIT_START_FREQ = 10.0 # 10 Hz
HIT_START_DT = rospy.Duration(1.0/ HIT_START_FREQ)
HIT_DURATION = 0.010 # 10 msec
THRESHOLD_DISTANCE_PIXELS = 10.0 # when to claim fly is zapped
VELOCITY_MODE_THRESHOLD_PIXELS = 20.0 # when to switch from postion to velocity mode

class MaybeTargetedObject:
    def __init__(self,msg,past):
        self.msg = msg
        self.last_hit_time = past
    def __str__(self):
        s = self.msg.state_vec
        return 'obj %d at (%.1f,%.1f), last hit %s'%(self.msg.obj_id,s[0],s[1], self.last_hit_time)
    def __repr__(self):
        return 'MaybeTargetedObject('+str(self)+')'
    def update(self,msg):
        self.msg = msg
    def get_last_hit_time(self):
        return self.last_hit_time
    def set_last_hit_time(self,new_hit_time):
        self.last_hit_time = new_hit_time

class Targeter:
    def __init__(self, cal_fname, borders_x=(0, 500), 
                 borders_y=(0, 500), mask_image=None):
        self.cal = load_calibration(cal_fname)
        rospy.init_node('flymad_targeter')
        self.past = rospy.Time.now() - rospy.Duration( 1e6 )
        self.future = rospy.Time.now() + rospy.Duration( 1e6 )

        if mask_image is None:
            #borders in left handed coordinate system
            self.in_target_area = (lambda state_vec:
                ((int(borders_x[0]) <= state_vec[1] <= int(borders_x[1])) and
                 (int(borders_y[0]) <= state_vec[0] <= int(borders_y[1]))) )
        else:
            img = Image.open(mask_image)
            assert img.size == (600, 600)
            assert img.mode == 'RGB'
            # we are only picking the red channel for masking
            mask = np.asarray(img)[:,:,0] >= 255 
            self.in_target_area = (lambda state_vec:
                mask[np.clip(int(state_vec[0]+0.5), 0, img.size[0]),
                     np.clip(int(state_vec[1]+0.5), 0, img.size[1])] )

        _ = rospy.Subscriber('/flymad/tracked',
                             TrackedObj,
                             self.on_tracking)
        _ = rospy.Subscriber('/flymad_micro/position_echo',
                             MicroPosition,
                             self.on_dac)
        self.pub_dac_position = rospy.Publisher('/flymad_micro/position',
                                                MicroPosition,
                                                tcp_nodelay=True)
        self.pub_dac_velocity = rospy.Publisher('/flymad_micro/velocity',
                                                MicroVelocity,
                                                tcp_nodelay=True)
        self.pub_laser = rospy.Publisher('/flymad_micro/laser',
                                         UInt8,
                                         tcp_nodelay=True)

        self.pub_targeted = rospy.Publisher('/flymad/targeted',
                                            StampedObject,
                                            tcp_nodelay=True)

        self.incoming_data_queue = Queue.Queue()
        self.tracked_objects = {} # a dict of currently tracked objects
        self.hit_dict = {} # dict of objects we want to zap
        self.dacs = 0,0
        self.last_vals = None
        time.sleep(0.4) # give ROS a chance to start up?!
        self.stop_tracking(None)

        self.current_plan = ('idle',None) # a 2 (or more length) tuple, with string
                                          # as first element, MaybeTrackedObject
                                          # instance as second element.

    def on_dac(self,msg):
        self.dacs = msg.posA, msg.posB

    def _get_current_dacs(self):
        return self.dacs

    def stop_tracking(self,old_obj_id):
        rospy.loginfo('stopped targeting object %s'%old_obj_id)

        msg = MicroVelocity()
        msg.velA = myint32(0)
        msg.velB = myint32(0)
        this_vels = msg.velA, msg.velB
        if this_vels != self.last_vals:
            self.pub_dac_velocity.publish(msg)
            self.last_vals = this_vels

    def on_tracking(self, msg):
        # called by ros subscriber thread
        self.incoming_data_queue.put(msg)

    def update(self):
        '''figure out what to do.

	this gets called at a high rate'''
        # get any new tracking data ------------------------
        while True:
            try:
                msg = self.incoming_data_queue.get_nowait()
            except Queue.Empty:
                break
            # we have new tracking data
            obj_id = msg.obj_id

            if obj_id not in self.tracked_objects:
                obj = MaybeTargetedObject( msg, self.past )
                self.tracked_objects[ obj_id ] = obj
            else:
                self.tracked_objects[ obj_id ].update( msg )

            print self.tracked_objects

            if not msg.is_living:
                del self.tracked_objects[ msg.obj_id ]

        # update our list of flies we want to hit ----------
        # TODO: update this based on where flies are, etc.
        orig_obj_ids = set(self.hit_dict.keys())
        cur_obj_ids = set(self.tracked_objects.keys())

        newly_dead_obj_ids = orig_obj_ids - cur_obj_ids
        newly_born_obj_ids = cur_obj_ids - orig_obj_ids 

        

        #we only put objects into the hit_dict if they are in the right part of the arena
        for obj_id in newly_born_obj_ids:
            if self.in_target_area(s):
                self.hit_dict[obj_id] = self.tracked_objects[obj_id]
        
        #we put objects out of the hit_dict if they get out of the right part of the arena
        for obj_id in self.hit_dict.keys():
            s=self.hit_dict[obj_id].msg.state_vec
            if not self.in_target_area(s):
                del self.hit_dict[obj_id]
                #we have to somehow abort the current plan
                if obj_id in newly_born_obj_ids:
                    newly_born_obj_ids.remove(obj_id)
                if obj_id in newly_dead_obj_ids:
                    newly_dead_obj_ids.remove(obj_id)
                

        #we put objects in the hit_dict if they get to the right part of the arena
        for obj_id in cur_obj_ids:
            s=self.tracked_objects[obj_id].msg.state_vec
            if self.in_target_area(s):
                self.hit_dict[obj_id]=self.tracked_objects[obj_id]

        for obj_id in newly_dead_obj_ids:
            del self.hit_dict[obj_id]
            # abort current plan if it involves this object
            if self.current_plan[0] != 'idle':
                obj = self.current_plan[1]
                if obj.msg.obj_id == obj_id:
                    self.current_plan = ('idle',None)
                    self.point_mirrors_at_nothing()


        # --------------------------------------------------
        now = rospy.Time.now()

        if self.current_plan[0] == 'idle':
            oldest_hit_time = self.future
            oldest_hit_obj = None

            for obj_id in self.hit_dict:
                obj = self.hit_dict[obj_id]
                this_last_hit_time = obj.get_last_hit_time()
                if this_last_hit_time < oldest_hit_time:
                    oldest_hit_time = this_last_hit_time
                    oldest_hit_obj = obj

            if oldest_hit_obj is not None:
                # now we have the oldest hit fly
                time_since_last_hit = now - oldest_hit_time
                if time_since_last_hit > HIT_START_DT:
                    self.set_current_plan('point mirror pre zap',oldest_hit_obj, now)

        if self.current_plan[0] == 'point mirror pre zap':
            obj = self.current_plan[1]
            self.point_mirrors_at_obj(obj)
            laser_distance = self.get_laser_distance(obj)
            if laser_distance < THRESHOLD_DISTANCE_PIXELS or (now - self.current_plan[2] ) > rospy.Duration(0.5):
                self.set_current_plan('zap start',obj)
            
        if self.current_plan[0] == 'zap start':
            obj = self.current_plan[1]
            self.point_mirrors_at_obj(obj)
            self.pub_laser.publish( 255 )
            self.set_current_plan('zap continue',obj,now)

        if self.current_plan[0] == 'zap continue':
            obj = self.current_plan[1]
            obj.set_last_hit_time(now)
            laser_start_time = self.current_plan[2]
            self.point_mirrors_at_obj(obj)
            this_duration = now - laser_start_time
            dur_sec = this_duration.to_sec()
            if dur_sec > HIT_DURATION:
                self.pub_laser.publish( 255 )
                if self.current_plan[0] != 'idle':
                    print obj
                    self.set_current_plan('idle',None)


    def set_current_plan(self, *args):
        self.current_plan = args
        print self.current_plan


    def get_current_predicted_xy(self,obj):
        now = rospy.Time.now()
        msg = obj.msg

        dt = now-msg.header.stamp # time elapsed since we have updated information
        dt_sec = dt.to_sec()

        # calculate fly position in pixel coordinates
        s = msg.state_vec
        x = s[0] + s[2]*(dt_sec+MOTOR_LAG)
        y = s[1] + s[3]*(dt_sec+MOTOR_LAG)

        x = int(max(0,x))
        y = int(max(0,y))
        return x,y

    def get_laser_distance(self,obj):
        x,y = self.get_current_predicted_xy(obj)

        aa, ab = self._get_current_dacs()
        dac_pixel_x = self.cal.d2px((aa,ab))
        dac_pixel_y = self.cal.d2py((aa,ab))

        laser_distance = np.sqrt((dac_pixel_x-x)**2 + (dac_pixel_y-y)**2)
        return laser_distance

    def point_mirrors_at_obj(self,obj):
        x,y = self.get_current_predicted_xy(obj)
        self.point_mirrors_at_xy(x,y,obj.msg.obj_id)

    def point_mirrors_at_nothing(self):
        self.point_mirrors_at_xy(250,250,0)

    def point_mirrors_at_xy(self,x,y,obj_id):
        # desired
        bad_data = False
        try:
            daca = self.cal.p2da[y,x]
            dacb = self.cal.p2db[y,x]
        except IndexError:
            bad_data = True
        else:
            if np.isnan( daca ) or np.isnan( dacb ):
                bad_data = True
        
        if bad_data:
            # Hmm, should we do something more?
            return

        aa, ab = self._get_current_dacs()
        dac_pixel_x = self.cal.d2px((aa,ab))
        dac_pixel_y = self.cal.d2py((aa,ab))

        laser_distance = np.sqrt((dac_pixel_x-x)**2 + (dac_pixel_y-y)**2)

        if laser_distance < VELOCITY_MODE_THRESHOLD_PIXELS:
            # velocity mode
            print "velocity_mode"

            diffa = daca-aa
            diffb = dacb-ab

            if (diffa**2 + diffb**2) < 1:
                print 'vel zero'
                vela = 0
                velb = 0
            else:
                vela = diffa*K_PROPORTIONAL
                velb = diffb*K_PROPORTIONAL
                print str(vela) + "vela" 
                print str(velb) + "velb" 

            if np.isnan(vela) or np.isnan(velb):
                return

            msg = MicroVelocity()
            msg.velA = myint32(vela)
            msg.velB = myint32(velb)

            this_vels = msg.velA, msg.velB
            if this_vels != self.last_vals:
                self.pub_dac_velocity.publish(msg)
                self.last_vals = this_vels
        else:
            # position mode
            print "position_mode"
            a = int(np.round(daca))
            b = int(np.round(dacb))
            msg = MicroPosition()
            msg.posA = a
            msg.posB = b
            assert msg.posA==a
            assert msg.posB==b
            this_vals = msg.posA, msg.posB
            if this_vals != self.last_vals:
                self.pub_dac_position.publish(msg)
                self.last_vals = this_vals

            ix = msg.posA, msg.posB
            px = self.cal.d2px(ix)
            py = self.cal.d2py(ix)

        msg = StampedObject()
        msg.header.stamp = rospy.Time.now()
        msg.obj_id = obj_id
        self.pub_targeted.publish(msg)

    def run(self):
        r = rospy.Rate(200) # 200hz
        startall = time.time()
        while not rospy.is_shutdown() and time.time() - startall < 600:
            self.update()
            r.sleep() # cycle at 200 Hz
        self.pub_laser.publish( 0 )
        exit()    


if __name__=='__main__':
    import argparse
    parser = argparse.ArgumentParser()
    parser.add_argument('--borders_x', nargs=2, metavar=('X0','X1'),
                            default=(0, 500), help='borders for targeting')
    parser.add_argument('--borders_y', nargs=2, metavar=('Y0','Y1'),
                            default=(0, 500), help='borders for targeting')
    parser.add_argument('--mask_image', default=None,
                            help='mask image for targeting')

    args=rospy.myargv()[2:]
    parsed = vars(parser.parse_args(args))

    t = Targeter(cal_fname, **parsed)
    t.run()

