#!/usr/bin/env python
from gi.repository import Gtk, Gdk, GObject, GLib

GObject.threads_init()
Gdk.threads_init()

import sys
import numpy as np
import threading

import cairo
from benu import benu

import roslib; roslib.load_manifest('flymad')
import rospy

from flymad.laser_camera_calibration import load_calibration

from flymad.msg import Raw2dPositions, TrackedObj
from geometry_msgs.msg import Pose2D
from flymad.msg import MicroPosition

class PixelCoordWidget(Gtk.DrawingArea):
    UPDATE_FREQ = 30
    def __init__ (self):
        super(PixelCoordWidget,self).__init__()
        Gtk.DrawingArea.__init__(self)
        self.lock = threading.Lock()
        with self.lock:
            self.laser_x = np.nan
            self.laser_y = np.nan
            self.pts_x = np.array([])
            self.pts_y = np.array([])
            self.dataw = 1024
            self.datah = 768
            self.living_objs = {}
        self.backbuf = None

        GLib.timeout_add(1000/self.UPDATE_FREQ, self.on_update)

    def do_configure_event(self,event):
        with self.lock:
            self.w = event.width
            self.h = event.height

        if self.backbuf is not None:
            self.backbuf.finish()
            self.backbuf = None

        self.backbuf = cairo.ImageSurface(
            cairo.FORMAT_ARGB32,
            self.get_allocated_width(),
            self.get_allocated_height())

        self.on_update()

        return False

    def do_draw(self, context):
        if self.backbuf is not None:
            context.set_source_surface(self.backbuf, 0.0, 0.0)
            context.paint()
        else:
            print 'invalid back buffer'
        return False

    def do_get_preferred_width(self):
        return 640, 640

    def do_get_preferred_height(self):
        return 480, 480

    def on_data(self, msg):
        x = np.array([p.x for p in msg.points])
        y = np.array([p.y for p in msg.points])
        with self.lock:
            self.pts_x = x
            self.pts_y = y

    def on_tracking(self, msg):
        with self.lock:
            if msg.is_living:
                xy = (msg.state_vec[0],msg.state_vec[1])
                self.living_objs[msg.obj_id] = xy
            else:
                try:
                    del self.living_objs[msg.obj_id]
                except KeyError:
                    pass

    def on_dac_pixels(self,px,py):
        with self.lock:
            self.laser_x = px
            self.laser_y = py

    def on_update(self):
        bb = self.backbuf
        if bb is not None:
            context = cairo.Context(bb)
            bc = benu.ExternalSurfaceCanvas(context,color_rgba=(0,0,0,1))
            with self.lock:
                device_rect = (10,10,self.w-20,self.h-20)
                user_rect = (0,0,self.dataw,self.datah)
                with bc.set_user_coords( device_rect,
                                         user_rect ):
                    bc.scatter( [self.laser_x],
                                [self.laser_y],
                                color_rgba=(1,0.0,0.0,1.0),
                                radius=6.0,
                                )
                    bc.scatter( self.pts_x,
                                self.pts_y,
                                color_rgba=(0,1,0,1),
                                radius=3.0,
                                )
                    bc.plot( [0,0,self.dataw, self.dataw],
                             [0,self.datah,self.datah,0],
                             color_rgba=(0,1,0,1),
                             close_path=True,
                             linewidth=3)
                    for obj_id in self.living_objs:
                        x,y = self.living_objs[obj_id]
                        bc.scatter( [x],[y],
                                    color_rgba=(1,1,0,1),
                                    radius=5.0,
                                    )
                        bc.text( str(obj_id), x+5,y+5,
                                    color_rgba=(1,1,0,1),
                                    )

            bb.flush()
            self.queue_draw()
        return True

class ViewerApp(Gtk.Window):
    def __init__(self,cal_fname=None):
        super(ViewerApp,self).__init__()
        if cal_fname is not None:
            rospy.loginfo('starting viewer with calibration %s'%cal_fname)
            self.cal = load_calibration(cal_fname)
        else:
            rospy.loginfo('starting viewer with no calibration')
            self.cal = None
        self.set_title ("FlyMAD Viewer")

        rospy.init_node('viewer')

        box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=5)

        cal_fname_label = Gtk.Label("Calibration: %s"%cal_fname)
        box.pack_start(cal_fname_label,False,False,0)

        self.pcw = PixelCoordWidget()
        box.pack_start(self.pcw,True,True,0)

        hb = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=5)
        hb.pack_start(box, True, True, 0)

        store = Gtk.ListStore(int)
        tv = Gtk.TreeView(store)
        tv.append_column(
            Gtk.TreeViewColumn("Object ID", Gtk.CellRendererText(), text=0))
        tv.connect("row-activated", self.on_row_dbl_clicked)
        hb.pack_start(tv,False,False,0)

        self.add(hb)

        self.connect_after('destroy', Gtk.main_quit)
        self.show_all()

        _ = rospy.Subscriber('/flymad_micro/position_echo',
                             MicroPosition,
                             self.on_dac)

        _ = rospy.Subscriber('/flymad/raw_2d_positions',
                             Raw2dPositions,
                             self.on_data)
        _ = rospy.Subscriber('/flymad/tracked',
                             TrackedObj,
                             self.on_tracking)

        rosthread = threading.Thread(name="ros spin thread", target=rospy.spin)
        rosthread.daemon = True
        rosthread.start()

    def on_row_dbl_clicked(self, treeview, treepath, treecolumn):
        obj_id = treeview.get_model()[treepath][0]

    def on_data(self, msg):
        self.pcw.on_data(msg)

    def on_tracking(self, msg):
        self.pcw.on_tracking(msg)

    def on_dac(self,msg):
        if self.cal is not None:
            ix = msg.posA, msg.posB
            px = self.cal.d2px(ix)
            py = self.cal.d2py(ix)
            self.pcw.on_dac_pixels( px, py )

if __name__ == "__main__":
    argv = rospy.myargv()
    if len(argv)==2:
        cal_fname = argv[1]
    else:
        assert len(argv)==1
        cal_fname = None
    app = ViewerApp(cal_fname)
    sys.exit(Gtk.main())
