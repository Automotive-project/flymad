#!/usr/bin/env python
import serial
import numpy as np
import threading
import time

import roslib; roslib.load_manifest('flymad')
import rospy
from std_msgs.msg import UInt8, UInt16, String, Float32
from flymad.msg import MicroVelocity, MicroPosition
from flymad.util import myint16, dac_value_wrap

class FlyMADMicro(object):
    def __init__(self):
        rospy.init_node('flymad_micro')
        _ = rospy.Subscriber('~position', MicroPosition, self.position_callback)
        _ = rospy.Subscriber('~velocity', MicroVelocity, self.velocity_callback)
        self._pub_dac_position = rospy.Publisher('~position_echo',
                                                MicroPosition,
                                                tcp_nodelay=True)
        self._pub_adc_raw = rospy.Publisher('~adc',
                                        UInt16,
                                        tcp_nodelay=True)
        self._pub_adc_sca = rospy.Publisher('~adc_scaled',
                                        Float32,
                                        tcp_nodelay=True)

        self._send_timezone()

        port = rospy.get_param( '~port', default = '/dev/ttyUSB0' )
        try:
            self.ser = serial.Serial(port=port,
                                     timeout=0.1,
                                     baudrate=115200,
                                     )
            self.ser.open()
            rospy.loginfo('opened serial port: %s'%port)
        except serial.serialutil.SerialException, err:
            rospy.logwarn('could not open serial port: %s'%(str(err),))
            self.ser = None

        self._buf = ''
        self.velocity_mode = False

        self._debug = rospy.get_param('~debug', 0)
        #an adc_scale of 0 disables adc sampling
        self._adc_scale = float(rospy.get_param('~adc_scale', 1.0))

        if self._debug:
            print 'debug mode on (%d)' % self._debug
            print '\t0 = disabled'
            print '\t1 = print sent commands'
            print '\t2 = print recieved commands'
        else:
            rospy.loginfo('debug mode disabled (set param debug > 0) to enable')

        self.lock = threading.Lock()
        with self.lock:
            self._last_posA = 0
            self._last_posB = 0
            self._last_velA = 0
            self._last_velB = 0
            self._last_vel_time = rospy.get_time()
        rospy.Timer( rospy.Duration(1.0/100.0),
                     self.on_timer )

    def _send_timezone(self):
        pub_timezone = rospy.Publisher('/timezone',
                                       String,
                                       latch=True)
        msg = String()
        msg.data = time.tzname[0]
        pub_timezone.publish(msg)

    def position_callback(self,msg):
        if self._debug:
            print 'msg: position:',msg.posA, msg.posB

        self._update(laser=msg.laser, posA=msg.posA, posB=msg.posB)

    def velocity_callback(self,msg):
        if self._debug:
            print 'msg: velocity:',msg.velA, msg.velB

        self._update(laser=msg.laser, velA=msg.velA, velB=msg.velB)

    def _update(self, 
                laser=None,
                posA=None, posB=None,
                velA=None, velB=None):

        cmd = 0x00
        argA = 0
        argB = 0

        if self._adc_scale > 0:
            cmd |= 0x08

        if laser:
            cmd |= 0x02

        if velA is not None or velB is not None:
            assert posA is None
            assert posB is None
            assert velA is not None
            assert velB is not None

            self.velocity_mode = True
            argA = velA
            argB = velB

            with self.lock:
                self._last_velA = velA
                self._last_velB = velB
                self._last_vel_time = rospy.get_time()

        if posA is not None or posB is not None:
            assert posA is not None
            assert posB is not None
            assert velA is None
            assert velB is None

            self.velocity_mode = False
            if dac_value_wrap(posA) != posA:
                raise ValueError("position A value (%d) too large"%posA)
            if dac_value_wrap(posB) != posB:
                raise ValueError("position B value (%d) too large"%posB)
            argA = posA
            argB = posB

            with self.lock:
                self._last_posA = posA
                self._last_posB = posB
                self._last_velA = 0
                self._last_velB = 0
                self._last_vel_time = rospy.get_time()

        if self.velocity_mode:
            cmd |= 0x04

        serstr = '%d %d %d\n'%(cmd, argA, argB)
        if self._debug:
            print 'tx : 0x%X %d %d' % (cmd, argA, argB)
        if self.ser is not None:
            self.ser.write(serstr)

    def on_timer(self, event):
        with self.lock:
            # publish best guess of DAC positions
            now = rospy.get_time()
            dt = now-self._last_vel_time

            a = self._last_posA + self._last_velA*dt
            b = self._last_posB + self._last_velB*dt

            a = dac_value_wrap(a)
            b = dac_value_wrap(b)
            self._last_posA = a
            self._last_posB = b
            self._last_vel_time = now

        msg = MicroPosition()
        msg.posA = a
        msg.posB = b
        self._pub_dac_position.publish(msg)

    def run(self):
        while not rospy.is_shutdown():
            if self.ser is not None:
                buf = self.ser.read()
                if len(buf):
                    self._handle_read(buf)
            # We'd call rospy.spinOnce() here if it existed.

    def _handle_read(self,inbuf):
        self._buf += inbuf
        lines = self._buf.split('\r\n')
        self._buf = lines.pop() # returns '' when last chars were \r\n
        line = None
        for line in lines:
            if self._debug:
                print 'rx :',repr(line)

        # take last line (most current) and update it
        if line is not None:
            try:
                mode, dacA, dacB, adc = map(int,line.split())
            except:
                print 'invalid comm packet'
                return

            dacA = dac_value_wrap(dacA)
            dacB = dac_value_wrap(dacB)
            if self._debug:
                print 'rxu: %d %d %d'%(mode, dacA, dacB)

            self._pub_adc_raw.publish(adc)
            self._pub_adc_sca.publish(adc * self._adc_scale)

            with self.lock:
                self._last_posA = dacA
                self._last_posB = dacB
                self._last_vel_time = rospy.get_time()

if __name__=='__main__':
    flymad_micro=FlyMADMicro()
    flymad_micro.run()
