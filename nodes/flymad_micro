#!/usr/bin/env python
import serial
import numpy as np
import threading
import time

import roslib; roslib.load_manifest('flymad')
import rospy
from std_msgs.msg import UInt8, String
from flymad.msg import MicroVelocity, MicroPosition
from flymad.util import myint16, dac_value_wrap

class FlyMADMicro(object):
    def __init__(self):
        rospy.init_node('flymad_micro')
        _ = rospy.Subscriber('~laser', UInt8, self.laser_callback)
        _ = rospy.Subscriber('~position', MicroPosition, self.position_callback)
        _ = rospy.Subscriber('~velocity', MicroVelocity, self.velocity_callback)
        self.pub_dac_position = rospy.Publisher('/flymad_micro/position_echo',
                                                MicroPosition,
                                                tcp_nodelay=True)
        self.pub_timezone = rospy.Publisher('/timezone',
                                            String )

        port = rospy.get_param( '~port', default = '/dev/ttyACM0' )
        try:
            self.ser = serial.Serial(port=port,
                                     timeout=0.1,
                                     baudrate=115200,
                                     )
            self.ser.open()
            rospy.loginfo('opened serial port: %s'%port)
        except serial.serialutil.SerialException, err:
            rospy.logwarn('could not open serial port: %s'%(str(err),))
            self.ser = None
        self._buf = ''
        self.laser = 0
        self.velocity_mode = False
        self._debug = False
        if self._debug:
            print 'debug mode on'

        self.lock = threading.Lock()
        with self.lock:
            self._last_posA = 0
            self._last_posB = 0
            self._last_velA = 0
            self._last_velB = 0
            self._last_vel_time = rospy.get_time()
        rospy.Timer( rospy.Duration(1.0/100.0),
                     self.on_timer )
        rospy.Timer( rospy.Duration(1.0),
                     self.on_slow_timer )

    def laser_callback(self,msg):
        val = msg.data
        self._update(laser=val)

    def position_callback(self,msg):
        if self._debug:
            print 'got position:',msg.posA, msg.posB

        self._update(posA=msg.posA, posB=msg.posB)

    def velocity_callback(self,msg):
        if self._debug:
            print 'got velocity:',msg.velA, msg.velB

        self._update(velA=msg.velA, velB=msg.velB)

    def _update(self,
                laser=None,
                posA=None, posB=None,
                velA=None, velB=None):
        if laser is not None:
            self.laser = laser


        cmd = 0x01
        argA = 0
        argB = 0

        if self.laser:
            cmd |= 0x02

        if velA is not None or velB is not None:
            assert posA is None
            assert posB is None
            assert velA is not None
            assert velB is not None

            self.velocity_mode = True
            argA = velA
            argB = velB

            with self.lock:
                self._last_velA = velA
                self._last_velB = velB
                self._last_vel_time = rospy.get_time()

        if posA is not None or posB is not None:
            assert posA is not None
            assert posB is not None
            assert velA is None
            assert velB is None

            self.velocity_mode = False
            if dac_value_wrap(posA) != posA:
                raise ValueError("position A value (%d) too large"%posA)
            if dac_value_wrap(posB) != posB:
                raise ValueError("position B value (%d) too large"%posB)
            argA = posA
            argB = posB

            with self.lock:
                self._last_posA = posA
                self._last_posB = posB
                self._last_velA = 0
                self._last_velB = 0
                self._last_vel_time = rospy.get_time()

        if self.velocity_mode:
            cmd |= 0x04

        serstr = '%d %d %d\n'%(cmd, argA, argB)
        if self._debug:
            print 'sending: ',repr(serstr)
        if self.ser is not None:
            self.ser.write(serstr)

    def on_slow_timer(self, event):
        self.pub_timezone.publish(time.tzname[0])

    def on_timer(self, event):
        with self.lock:
            # publish best guess of DAC positions
            now = rospy.get_time()
            dt = now-self._last_vel_time

            a = self._last_posA + self._last_velA*dt
            b = self._last_posB + self._last_velB*dt

            a = dac_value_wrap(a)
            b = dac_value_wrap(b)
            self._last_posA = a
            self._last_posB = b
            self._last_vel_time = now

        msg = MicroPosition()
        msg.posA = a
        msg.posB = b
        self.pub_dac_position.publish(msg)

    def run(self):
        while not rospy.is_shutdown():
            if self.ser is not None:
                buf = self.ser.read()
                if len(buf):
                    self._handle_read(buf)
            # We'd call rospy.spinOnce() here if it existed.

    def _handle_read(self,inbuf):
        self._buf += inbuf
        lines = self._buf.split('\r\n')
        self._buf = lines.pop() # returns '' when last chars were \r\n
        line = None
        for line in lines:
            if self._debug:
                print '                                      read: ',repr(line)

        # take last line (most current) and update it
        if line is not None:
            dacA, dacB = map(int,line.split()[-2:])
            dacA = dac_value_wrap(dacA)
            dacB = dac_value_wrap(dacB)
            if self._debug:
                print '                                      last: %d %d'%(dacA, dacB)

            with self.lock:
                self._last_posA = dacA
                self._last_posB = dacB
                self._last_vel_time = rospy.get_time()

if __name__=='__main__':
    flymad_micro=FlyMADMicro()
    flymad_micro.run()
