#!/usr/bin/env python
import serial
import numpy as np
import threading

import roslib; roslib.load_manifest('flymad')
import rospy
from std_msgs.msg import UInt8
from flymad.msg import MicroVelocity, MicroPosition
from flymad.util import myint16, dac_value_wrap

class FlyMADMicro(object):
    def __init__(self):
        rospy.init_node('flymad_micro')
        _ = rospy.Subscriber('~laser', UInt8, self.laser_callback)
        _ = rospy.Subscriber('~position', MicroPosition, self.position_callback)
        _ = rospy.Subscriber('~velocity', MicroVelocity, self.velocity_callback)
        self.pub_dac_position = rospy.Publisher('/flymad_micro/position_echo',
                                                MicroPosition,
                                                tcp_nodelay=True)

        port = rospy.get_param( '~port', default = '/dev/ttyACM0' )
        try:
            self.ser = serial.Serial(port=port,
                                     timeout=0.1,
                                     baudrate=115200,
                                     )
            self.ser.open()
            rospy.loginfo('opened serial port: %s'%port)

        except serial.serialutil.SerialException, err:
            rospy.logwarn('could not open serial port: %s'%(str(err),))
            self.ser = None
        self._buf = ''
        self.laser = 0
        self.velocity_mode = False
        self._debug = True
        if self._debug:
            print 'debug mode on'

        self.lock = threading.Lock()
        with self.lock:
            self._last_posA = 0
            self._last_posB = 0
            self._last_velA = 0
            self._last_velB = 0
            self._last_vel_time = rospy.get_time()

    def laser_callback(self,msg):
        val = msg.data
        self._update(laser=val)

    def position_callback(self,msg):
        if self._debug:
            print 'got position:',msg.posA, msg.posB

        self._update(posA=msg.posA, posB=msg.posB)

    def velocity_callback(self,msg):
        if self._debug:
            print 'got velocity:',msg.velA, msg.velB

        self._update(velA=msg.velA, velB=msg.velB)

    def _update(self,
                laser=None,
                posA=None, posB=None,
                velA=None, velB=None):
        if laser is not None:
            self.laser = laser

        cmd = 0
        if self.laser:
            cmd |= 0x02

        if velA is not None or velB is not None:
            assert posA is None
            assert posB is None
            assert velA is not None
            assert velB is not None

            self.velocity_mode = True
            argA = velA
            argB = velB

            with self.lock:
                self._last_velA = velA
                self._last_velB = velB
                self._last_vel_time = rospy.get_time()

        if posA is not None or posB is not None:
            assert posA is not None
            assert posB is not None
            assert velA is None
            assert velB is None

            self.velocity_mode = False
            if dac_value_wrap(posA) != posA:
                raise ValueError("position A value (%d) too large"%posA)
            if dac_value_wrap(posB) != posB:
                raise ValueError("position B value (%d) too large"%posB)
            argA = posA
            argB = posB

            with self.lock:
                self._last_posA = posA
                self._last_posB = posB
                self._last_velA = 0
                self._last_velB = 0
                self._last_vel_time = rospy.get_time()

        if self.velocity_mode:
            cmd |= 0x04

        if self._debug:
            cmd |= 0x01

        serstr = '%d %d %d\n'%(cmd, argA, argB)
        if self._debug:
            print 'sending: ',repr(serstr)
        if self.ser is not None:
            self.ser.write(serstr)

    def run(self):
        r = rospy.Rate(100)
        while not rospy.is_shutdown():
            if self._debug and self.ser is not None:
                buf = self.ser.read(100)
                if len(buf):
                    self._handle_read(buf)
            r.sleep()
            with self.lock:
                # publish best guess of DAC positions
                now = rospy.get_time()
                dt = now-self._last_vel_time

                a = self._last_posA + self._last_velA*dt
                b = self._last_posB + self._last_velB*dt

                a = dac_value_wrap(a)
                b = dac_value_wrap(b)
                self._last_posA = a
                self._last_posB = b
                self._last_vel_time = now

                msg = MicroPosition()
                msg.posA = myint16(np.round(a))
                msg.posB = myint16(np.round(b))
                try:
                    self.pub_dac_position.publish(msg)
                except:
                    print msg
                    raise

    def _handle_read(self,inbuf):
        self._buf += inbuf
        lines = self._buf.split('\r\n')
        self._buf = lines.pop()
        line = None
        for line in lines:
            print '                                      read: ',repr(line)
        if line is not None:
            dacA, dacB = map(int,line.split()[-2:])
            dacA = dac_value_wrap(dacA)
            dacB = dac_value_wrap(dacB)
            print '                                      last: %d %d'%(dacA, dacB)

            with self.lock:
                self._last_posA = dacA
                self._last_posB = dacB
                self._last_vel_time = rospy.get_time()

if __name__=='__main__':
    flymad_micro=FlyMADMicro()
    flymad_micro.run()
